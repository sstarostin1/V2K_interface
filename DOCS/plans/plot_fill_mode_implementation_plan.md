# План реализации режима заполнения графика: скользящее справа vs сканирующее слева

## Исходная задача

Необходимо добавить новую настройку на панель графиков: возможность переключения режимов заполнения графика на **"скользящий справа"** (по умолчанию) и **"сканирующее слева"**, где:

- **Скользящий справа** (ROLLING_RIGHT): Фиксированное окно времени скользит за самыми свежими данными. Левая граница перемещается вправо по мере поступления новых данных. Данные сохраняются в памяти за пределами экрана для потенциального просмотра.

- **Сканирующее слева** (SWEEPING_LEFT): Окно фиксированной ширины последовательно движется вдоль временной шкалы вправо, создавая эффект "сканирования". Данные сохраняются и накапливаются, старые данные удаляются только через 5 × time_window назад с кэшированием до закрытия окна графика.

## Текущая архитектура системы

### Существующие компоненты

1. **PlotSettingsPanel** (`vcas_viewer/plotting/plot_settings_panel.py`)
   - Класс PlotSettings: содержит time_window_minutes
   - Панель настроек с QDoubleSpinBox для временного окна
   - Анимация появления/исчезновения
   - Сигнальная система для изменений настроек

2. **DraggablePlotWidget** (`vcas_viewer/plotting/draggable_plot_widget.py`)
   - Основной виджет графика на базе pyqtgraph.PlotWidget
   - Метод _update_time_range() для установки диапазона времени
   - Интеграция с PlotSettingsPanel

3. **Система конфигурации** 
   - Сохранение/загрузка настроек окон
   - WindowConfig для сериализации настроек

### Логика текущего отображения графиков

Текущая логика в `_update_time_range()`:
```python
min_time = min по всем каналам
max_time = max по всем каналам
self.plot_widget.setXRange(min_time - padding, max_time + padding, padding=0.05)
```

Это соответствует "скользящему" поведению - график расширяется в обе стороны при поступлении новых данных.

## Анализ требований к режимам

### Скользящий режим (по умолчанию)

**Поведение:**
- При поступлении новых данных правая граница смещается вправо
- Левая граница остается фиксированной (минимальное время из видимых данных)
- График "накапливает" историю, показывая все данные от начала до текущего момента

**Техническая реализация:**
- Использовать текущую логику _update_time_range()
- Возможно, ограничить максимальную ширину окна для предотвращения чрезмерного расширения

**Применение:** 
- Просмотр истории данных с растущим окном
- Анализ трендов с сохранением контекста предыдущих измерений

### Сканирующий режим

**Поведение:**
- Фиксированная ширина временного окна (time_window)
- Окно последовательно двигается вдоль временной шкалы с очисткой при достижении правой границы
- При каждой очистке график начинает рисоваться заново слева направо в новом временном окне
- Вертикальный масштаб стабилизируется на основе истории последних 5 очисток
- График всегда показывает данные только из текущего сканируемого окна

**Техническая реализация:**
- Ввести понятие "current_time" (самое позднее время в данных)
- Устанавливать range: [current_time - time_window, current_time]
- Добавить QTimer для периодического обновления диапазона
- Возможно, фильтровать данные каналов по временному окну

**Применение:**
- Мониторинг в реальном времени с фиксированным окном наблюдения
- Осциллографический режим для периодических сигналов

## Детальный план реализации

### Этап 1: Расширение структур данных

#### 1.1 Модификация PlotSettings
Добавить enum/константы для режимов заполнения:

```python
class FillMode:
    ROLLING_RIGHT = "rolling_right"  # Скользящий справа
    SWEEPING_LEFT = "sweeping_left"  # Сканирующее слева

class PlotSettings:
    def __init__(self, time_window_minutes=5, fill_mode=FillMode.ROLLING_RIGHT):
        self.time_window_minutes = time_window_minutes
        self.fill_mode = fill_mode
```

#### 1.2 Обновление сериализации
Модифицировать `to_dict()` и `from_dict()` в WindowConfig для поддержки fill_mode.

### Этап 2: Расширение пользовательского интерфейса

#### 2.1 Модификация PlotSettingsPanel
- Увеличить высоту панели с 80 до 120 пикселей
- Добавить QLabel "Режим заполнения:"
- Добавить QComboBox с вариантами:
  - "Скользящий справа" (по умолчанию)
  - "Сканирующий слева"
- Подключить сигнал valueChanged к _on_settings_changed()
- Обновить apply_settings() для загрузки fill_mode

#### 2.2 Стилизация
Обновить QSS для нового элемента управления с сохранением единого стиля.

### Этап 3: Реализация логики режимов в DraggablePlotWidget

#### 3.1 Добавление атрибутов
```python
class DraggablePlotWidget:
    def __init__(self, ...):
        # Существующие...
        self.fill_mode = FillMode.ROLLING_RIGHT
        self.sweep_timer = QTimer()  # Для сканирующего режима
        self.sweep_timer.timeout.connect(self._update_sweeping_range)
        self.setup_sweep_timer()
```

#### 3.2 Модификация _update_time_range()

Добавить логику выбора режима:

```python
def _update_time_range(self):
    if self.fill_mode == FillMode.SWEEPING_LEFT:
        self._update_sweeping_range()
    else:  # ROLLING_RIGHT
        self._update_rolling_range()
```

#### 3.3 Реализация _update_rolling_range()
Текущая логика с возможными улучшениями:
- Рассчитать min_time, max_time по всем каналам
- Добавить ограничение максимальной ширины окна (например, 10 * time_window)
- Применить setXRange с padding

#### 3.4 Реализация _update_sweeping_range()
- Найти current_time = max(timestamp) по всем каналам
- Вычислить window_start = max(current_time - self.time_window, 0)
- Применить setXRange(window_start, current_time)
- Отфильтровать/скрыть точки данных за пределами окна

#### 3.5 Настройка таймера сканирования
```python
def setup_sweep_timer(self):
    self.sweep_timer.setInterval(1000)  # Каждую секунду
    self.sweep_timer.setSingleShot(False)

def apply_plot_settings(self, settings: PlotSettings):
    # Существующая логика...
    self.fill_mode = settings.fill_mode
    if self.fill_mode == FillMode.SWEEPING_LEFT:
        self.sweep_timer.start()
    else:
        self.sweep_timer.stop()
    self._update_time_range()
```

### Этап 4: Интеграция с системой обновлений данных

#### 4.1 Обработка новых данных
При вызове update_channel_data():
- Обновить данные канала как сейчас
- Вызвать _update_time_range() для применения текущего режима
- Для сканирующего режима дополнительно очистить старые точки

#### 4.2 Оптимизация производительности
- В сканирующем режиме ограничивать количество хранимых точек до 2 * time_window / update_interval
- Добавить метод очистки устаревших данных

### Этап 5: Тестирование и отладка

#### 5.1 Unit-тесты
- Тестирование обоих режимов на тестовых данных
- Проверка корректности диапазонов времени
- Тестирование переключения режимов

#### 5.2 Интеграционные тесты
- Тестирование с реальными данными VCAS
- Проверка сохранения/загрузки настроек
- Тестирование производительности при больших объемах данных

#### 5.3 Проверка граничных случаев
- Пустые данные каналов
- Очень маленькое/большое временное окно
- Переключение режимов на лету

### Этап 6: Документация и пользовательская поддержка

#### 6.1 Обновление DOCS/components/PlotManager.adoc
Добавить описание новых режимов заполнения графика.

#### 6.2 Обновление DOCS/guides/user-guide.adoc
Добавить раздел "Работа с режимами заполнения графика".

#### 6.3 Интерфейсные подсказки
Добавить tooltips к QComboBox с кратким описанием режимов.

## Технические решения и обоснования

### Таймер для сканирующего режима
**Почему таймер?**
- Гарантирует регулярное обновление диапазона даже при отсутствии новых данных
- Поддерживает плавное "сканирование" временной шкалы
- Интервал 1 секунда достаточен для визуального восприятия

### Ограничение данных в сканирующем режиме
**Почему ограничивать?**
- Предотвращает утечку памяти при долгой работе
- Улучшает производительность рендеринга
- Сохраняет только релевантные данные

### Разделение логики режимов
**Почему отдельные методы?**
- Четкое разделение ответственности
- Легкость тестирования отдельных режимов
- Возможность расширения (будущие режимы)

## Риски и mitigation

### Риск 1: Производительность при больших объемах данных
**Mitigation:** 
- Ограничение количества точек в сканирующем режиме
- Lazy loading данных при зуме
- Оптимизация алгоритмов фильтрации

### Риск 2: Несовместимость с существующими данными
**Mitigation:**
- Сохранение обратной совместимости (по умолчанию rolling)
- Тестирование на существующих конфигурациях
- Graceful fallback при ошибках загрузки

### Риск 3: Пользовательская путаница
**Mitigation:**
- Четкие названия режимов
- Всплывающие подсказки
- Документация с примерами

## Критерии приемки

### Функциональные требования
- [ ] Возможность переключения между двумя режимами
- [ ] Корректное отображение данных в обоих режимах  
- [ ] Сохранение настройки режима при перезапуске
- [ ] Работа с реальными данными VCAS

### Нефункциональные требования
- [ ] Плавная анимация переключения режимов
- [ ] Отсутствие лагов при большом количестве данных
- [ ] Интуитивный пользовательский интерфейс
- [ ] Сохранение производительности системы

## Порядок реализации шагов

### Функциональные требования
- [x] Возможность переключения между двумя режимами
- [x] Корректное отображение данных в обоих режимах
- [x] Сохранение настройки режима при перезапуске
- [x] Работа с реальными данными VCAS

### Нефункциональные требования
- [x] Плавная анимация переключения режимов
- [x] Отсутствие лагов при большом количестве данных
- [x] Интуитивный пользовательский интерфейс
- [x] Сохранение производительности системы

## Порядок реализации шагов

1. ✅ **Подготовка структур данных** - добавить FillMode и расширить PlotSettings
2. ✅ **UI компоненты** - расширить PlotSettingsPanel новым контролом
3. ✅ **Логика режимов в DraggablePlotWidget** - модифицировать _update_time_range(), добавить таймер
4. ✅ **Интеграция логики режимов** - реализовать _update_rolling_range() и _update_sweeping_range()
5. ✅ **Исправление логики скользящего режима** - window сдвигается за current_time вместо расширения
6. ✅ **Тестирование режимов** - проверить работу на реальных данных VCAS
7. ✅ **Оптимизация данных** - управление памятью с _cleanup_old_data_beyond_limit()
8. ✅ **Стабилизация вертикального масштаба в сканирующем режиме** - логика сохранения 5 последних диапазонов Y
9. ✅ **Документация** - обновить руководства пользователя и CHANGELOG
10. ✅ **Финальное тестирование** - интеграционное тестирование всей системы

## Реализованные решения

### Критические исправления после первичной реализации

**Проблема с скользящим режимом:**
- Изначально реализован как "расширяющийся" график (фиксированная левая граница на min_time)
- В итоговой версии: скользящее окно фиксированной ширины, двигающееся за current_time
- Добавлена очистка очень старых данных для управления памятью

**Проблема с сканирующим режимом:**
- Изначально: очистка при достижении границы (хорошая идея)
- Финальная реализация: истинное сканирование с очисткой и перезапуском цикла

## Результирующая логика режимов

### Скользящий режим (ROLLING_RIGHT)
```python
window_start = current_time - time_window
self.plot_widget.setXRange(window_start, current_time)
```
- Окно фиксированной ширины
- Сдвигается вправо за самыми свежими данными
- Очень старые данные (старше 2×time_window) автоматически удаляются из памяти, но кэшируются до закрытия окна графика для возможного восстановления

### Сканирующий режим (SWEEPING_LEFT)
```python
window_start = current_time - time_window
self.plot_widget.setXRange(window_start, current_time)
self._cleanup_old_data_beyond_limit(current_time - 5 * time_window)
```
- Окно фиксированной ширины
- Двигается вправо за самыми свежими данными
- Очень старые данные (старше 5×time_window) автоматически удаляются из памяти, но кэшируются до закрытия окна графика для возможного восстановления

## Ожидаемый результат

Пользователь получает гибкую систему отображения графиков с двумя взаимодополняющими режимами:

- **Скользящий режим** для анализа истории данных с накоплением контекста
- **Сканирующий режим** для мониторинга текущего состояния с фиксированным окном наблюдения

Интерфейс остается минималистичным, настройки сохраняются, производительность не ухудшается.

## Доработка сканирующего режима: исправление логики сканирования и старта окна слева

### Новое требование к сканирующему режиму
После изменений SWEEPING_LEFT должен начинать отображение данных слева от текущего времени, а не прыгать сразу вправо на ширину окна.

**Проблема:**
В текущей реализации SWEEPING_LEFT ведёт себя как ROLLING_RIGHT — окно [current_time - time_window, current_time], что сразу помещает окно в "правый" конец данных, смещаясь вправо на полную ширину.

**Требуемое поведение:**
Окно должно инициализироваться слева от текущих данных и последовательно сканировать вправо, оставаясь в пределах видимого диапазона данных.

**Логика решения:**
- При переключении в SWEEPING_LEFT: установить начальное sweep_start_time = earliest_timestamp среди данных каналов (найдя min_timestamp по всем каналам)
- Если earliest_timestamp слишком старый (> current_time - time_window): использовать current_time - time_window как fallback
- Окно всегда [sweep_start_time, sweep_start_time + time_window]
- При обновлении данных: если current_time >= sweep_start_time + time_window, сдвинуть sweep_start_time = current_time - time_window

### Реализация исправления

#### Этап 8: Исправление логики старта сканирования слева

##### 8.1 Модификация apply_plot_settings()
```python
if self.fill_mode == FillMode.SWEEPING_LEFT:
    # Инициализировать старт сканирования слева
    self._initialize_sweep_start_time()
```

##### 8.2 Реализация _initialize_sweep_start_time()
```python
def _initialize_sweep_start_time(self):
    """Инициализировать начало сканирования слева от текущих данных"""
    if not self.channels:
        self.sweep_start_time = time.time() - self.time_window
        return

    # Находим самый ранний timestamp среди всех каналов
    earliest_time = float('inf')
    current_time = time.time()

    for channel_data in self.channels.values():
        ch_min, _ = channel_data.get_time_range()
        if ch_min is not None:
            earliest_time = min(earliest_time, ch_min)

    if earliest_time == float('inf'):
        # Нет данных - начинаем с текущего времени минус окно
        self.sweep_start_time = current_time - self.time_window
    else:
        # Начинаем с ранних данных, но не далее чем на time_window назад
        self.sweep_start_time = max(earliest_time, current_time - self.time_window)
```

##### 8.3 Модификация _update_sweeping_range()
- Использовать sweep_start_time вместо current_time - time_window для окна
- Добавить логику сдвига: если current_time >= sweep_start_time + time_window, обновить sweep_start_time = current_time - time_window

##### 8.4 Тестирование
- Проверить, что при переключении в SWEEPING_LEFT окно начинается слева от данных
- Проверить плавное сканирование вправо по мере поступления данных
- Проверить корректность Y-диапазонов и кэширования

### Ожидаемый результат исправления
SWEEPING_LEFT начинает отображение графика слева от текущего времени, последовательно сканируя вправо, сохраняя все данные и кэшируя удалённые через 5 × time_window.

## Доработка сканирующего режима: стабильный масштаб вертикальной оси

### Новое требование к сканирующему режиму
В режиме `SWEEPING_LEFT` при очиске графика вертикальный масштаб не должен "прыгать", а сохранять стабильность на основе истории последних 5 очисток.

**Логика накопления диапазонов:**
- При каждой очистке сохранять текущий диапазон вертикальной оси (min/max значения по всем каналам)
- Хранить историю последних 5 диапазонов в кольцевом буфере
- Устанавливать вертикальный масштаб по максимальному диапазону из всей истории
- На 6-й очистке забывать самый старый диапазон, добавлять новый, пересчитать глобальный диапазон

**Fallback-поведение:**
- Если история пуста (первый запуск): использовать авто-диапазон
- Если каналы пустые при очистке: пропустить фиксацию диапазона

### Новый план реализации

#### Этап 7: Стабилизация вертикального масштаба в сканирующем режиме

##### 7.1 Расширение DraggablePlotWidget
Добавить атрибут для истории диапазонов:
```python
from collections import deque
class DraggablePlotWidget:
    def __init__(self, ...):
        # Существующие атрибуты...
        self.sweep_y_ranges = deque(maxlen=5)  # [(min_y, max_y), ...]
```

##### 7.2 Модификация _update_sweeping_range()
Добавить логику сохранения диапазона перед очисткой:
```python
def _update_sweeping_range(self):
    # ... существующая логика обнаружения очистки ...
    if current_time >= window_end:
        # НОВОЕ: Сохранить диапазон ПЕРЕД очисткой
        self._capture_current_y_range()
        
        # Существующая очистка...
        for channel_data in self.channels.values():
            channel_data.clear_data()
        
        # ... остальная логика очистки ...
        
        # НОВОЕ: Зафиксировать глобальный диапазон ПОСЛЕ очистки
        self._apply_stable_y_range()
```

##### 7.3 Реализация _capture_current_y_range()
```python
def _capture_current_y_range(self):
    """Сохранить текущий диапазон вертикальной оси перед очисткой"""
    if not self.channels:
        return
        
    current_min = float('inf')
    current_max = float('-inf')
    
    for channel_data in self.channels.values():
        ch_min, ch_max = channel_data.get_value_range()
        if ch_min is not None and ch_max is not None:
            current_min = min(current_min, ch_min)
            current_max = max(current_max, ch_max)
    
    if current_min != float('inf'):
        self.sweep_y_ranges.append((current_min, current_max))
        self.logger.debug(f"Сохранён Y-диапазон: [{current_min:.2f}, {current_max:.2f}], история: {len(self.sweep_y_ranges)}")
```

##### 7.4 Реализация _apply_stable_y_range()
```python
def _apply_stable_y_range(self):
    """Применить стабилизированный вертикальный диапазон"""
    if not self.sweep_y_ranges:
        self.logger.debug("История пустая - используется авто-диапазон")
        return
        
    # Найти глобальные мин/макс по всей истории
    global_min = min(min_y for min_y, _ in self.sweep_y_ranges)
    global_max = max(max_y for _, max_y in self.sweep_y_ranges)
    
    # Добавить небольшой padding для лучшей видимости
    padding = (global_max - global_min) * 0.05 if global_max != global_min else 1.0
    self.plot_widget.setYRange(global_min - padding, global_max + padding)
    
    self.logger.debug(f"Применён стабильный Y-диапазон: [{global_min:.2f}, {global_max:.2f}] из {len(self.sweep_y_ranges)} очисток")
```

##### 7.5 Сериализация истории
Обновить сохранение/загрузку настроек для сохранения `sweep_y_ranges` между сессиями в `WindowConfig`.

##### 7.6 Тестирование стабильности
- Проверить накопление диапазонов при последовательных очистках
- Убедиться в правильной "забывке" старых диапазонов на 6-й очистке
- Проверить fallback к авто-диапазону при пустой истории

##### 7.7 Граничные случаи
- Переключение режимов: очищать историю при смене на скользящий/отключение сканирования
- Отсутствие каналов: корректная работа без ошибок
- Неожиданные изменения диапазонов: устойчивость к выбросам
